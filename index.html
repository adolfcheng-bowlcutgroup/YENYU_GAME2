<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>å»ºç¯‰å¸«å¤§å¸«V2.20ç‰ˆ</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    body{
      margin:0; overflow:hidden;
      font-family:'Segoe UI',sans-serif;
      touch-action:manipulation;
      transition: background 1.2s ease;
      background: linear-gradient(#87CEEB, #cfefff);
    }

    #login{
      position:absolute; inset:0;
      display:grid; place-items:center;
      z-index:60;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.18s ease;
    }

    #login.show{ opacity:1; pointer-events:auto; }

    #login .backdrop{ position:absolute; inset:0; background: rgba(0,0,0,0.62); backdrop-filter: blur(2px); }

    #login .panel{
      position:relative;
      width:min(520px, 92vw);
      border-radius: 18px;
      padding: 18px;
      border: 2px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.30);
      box-shadow: 0 16px 50px rgba(0,0,0,0.35);
    }

    #ui{
      position:absolute;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      z-index:10;
      pointer-events:none;
      color:white;
      width: min(520px, calc(100vw - 24px));
      box-sizing: border-box;
      padding: 0 2px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    #hud-top{ 
      display:flex; 
      gap:10px; 
      width:100%; 
      box-sizing:border-box; 
    }
    
    .stat-card{
      flex: 1;
      background: rgba(0,0,0,0.28);
      padding: 10px 14px;
      border-radius: 14px;
      border: 2px solid rgba(78,204,163,0.55);
      backdrop-filter: blur(10px);
      min-width: 0;
      box-sizing: border-box;
    }

    .label{
      font-size: 12px;
      color: rgba(255,255,255,0.90);
      text-transform:uppercase;
      letter-spacing: 0.6px;
    }
    .value{
      font-size: 22px;
      font-weight: 900;
      margin-top: 2px;
      text-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }

    /* âœ… Timer + Round HUD åŒ…åœ¨åŒä¸€è¡Œï¼ˆRound æ”¾åœ¨ TIME å·¦ä¸‹è™•ï¼‰ */
    #hud-bottom{
      display:flex;
      gap:10px;
      align-items:stretch;
      width:100%;
      box-sizing:border-box;
    }
    #round-card{
      width: 140px;
      flex: 0 0 140px;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    #round-card .value{
      font-size: 20px;
    }

    #timer-card{ flex: 1; }
    #timer-bar{
      width:100%;
      height:6px;
      background: rgba(0,0,0,0.35);
      border-radius:3px;
      margin-top:8px;
      overflow:hidden;
    }
    #timer-fill{ width:100%; height:100%; background:#ff416c; }

    @keyframes timeWarnPulse {
      0%   { background: rgba(255, 65, 108, 0.00); }
      50%  { background: rgba(255, 65, 108, 0.35); }
      100% { background: rgba(255, 65, 108, 0.00); }
    }
    #timer-card.time-warn{
      animation: timeWarnPulse 0.9s ease-in-out infinite;
      border-color: rgba(255, 65, 108, 0.55);
    }

    #game-viewport{ width:100vw; height:100vh; }
    canvas{ display:block; }

    #overlay{
      position:absolute; inset:0;
      display:grid; place-items:center;
      z-index:50;
      opacity:0;
      pointer-events:none;
      transition: opacity 0.18s ease;
    }
    #overlay.show{ opacity:1; pointer-events:auto; }
    #overlay .backdrop{
      position:absolute; inset:0;
      background: rgba(0,0,0,0.62);
      backdrop-filter: blur(2px);
    }
    #overlay .panel{
      position:relative;
      width:min(560px, 92vw);
      border-radius: 18px;
      padding: 18px 18px 16px 18px;
      border: 2px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.30);
      box-shadow: 0 16px 50px rgba(0,0,0,0.35);
      color:white;
      max-height: 86vh;
      overflow: hidden;
    }
    #overlay h1{
      margin: 2px 0 8px 0;
      font-size: 40px;
      letter-spacing: 1px;
      font-weight: 900;
      text-shadow: 0 0 18px rgba(255,255,255,0.35);
    }
    #overlay p{
      margin: 0 0 10px 0;
      opacity: 0.92;
      line-height: 1.35;
      font-size: 16px;
    }

    /* âœ… Round3 TOTAL å¤§å­— */
    #ov-total-big{
      display:none;
      margin: 6px 0 10px 0;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(0,0,0,0.22);
      text-align:center;
    }
    #ov-total-big .k{
      font-size: 12px;
      opacity: 0.80;
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }
    #ov-total-big .v{
      margin-top: 4px;
      font-size: 70px;
      font-weight: 900;
      text-shadow: 0 0 18px rgba(255,255,255,0.22);
    }

    /* âœ… çµç®—ä¸»è¦å¤§å¡ï¼ˆRound1/2: ROUND SCOREï¼›Round3: TOTALï¼‰ */
    #ov-main-score{
      display:none;
      margin: 6px 0 10px 0;
      padding: 12px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.20);
      background: rgba(0,0,0,0.22);
      text-align:center;
    }
    #ov-main-score .k{
      font-size: 12px;
      opacity: 0.80;
      letter-spacing: 0.8px;
      text-transform: uppercase;
    }
    #ov-main-score .v{
      margin-top: 4px;
      font-size: 44px;
      font-weight: 900;
      text-shadow: 0 0 18px rgba(255,255,255,0.22);
    }

    .summary{
      margin-top: 10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    /* âœ… çµç®—ä¸‹æ’ä¸‰å¡ï¼ˆLEVEL/SCORE/COMBOï¼‰ */
    .summary.r3{
      grid-template-columns: 1fr 1fr 1fr;
    }

    .card{
      border-radius: 14px;
      padding: 12px 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.22);
      transition: box-shadow 0.18s ease, border-color 0.18s ease;
    }
    .card .k{ font-size: 12px; color: rgba(255,255,255,0.75); text-transform: uppercase; letter-spacing: 0.8px; }
    .card .v{ margin-top: 4px; font-size: 26px; font-weight: 900; }

    @keyframes cardFlash {
      0%   { border-color: rgba(255,255,255,0.16); box-shadow: 0 0 0 rgba(0,0,0,0); }
      35%  { border-color: rgba(255,209,102,0.95); box-shadow: 0 0 22px rgba(255,209,102,0.35); }
      100% { border-color: rgba(255,255,255,0.16); box-shadow: 0 0 0 rgba(0,0,0,0); }
    }
    .flash-once{
      animation: cardFlash 0.52s ease-out 1;
    }
    #ov-total-big.flash-once,
    #ov-main-score.flash-once{
      animation: cardFlash 0.58s ease-out 1;
    }

    .actions{
      margin-top: 12px;
      display:block;
    }

    #btn-retry{
      width:100%;
      padding: 10px 12px;
      border-radius: 14px;
      font-weight: 900;
      font-size: 16px;
    }
    button{
      appearance:none; border:none;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 900;
      cursor:pointer;
      background: #4ecca3;
      color: #0b1a14;
      pointer-events:auto;
    }
    button:active{ transform: scale(0.98); }
    button:disabled{
      opacity: 0.55;
      cursor: default;
    }
    button:disabled:active{ transform: none; }

    .leaderboard{
      margin-top: 12px;
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
    }
    .lb-title{ font-weight: 900; letter-spacing: 0.6px; margin-bottom: 2px; }
    .lb-sub{ font-size: 12px; opacity: 0.75; margin-bottom: 8px; }
    .lb-scroll{
      max-height: 260px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
      padding-right: 6px;
    }
    .lb-row{
      display:grid;
      grid-template-columns: 42px 1fr 140px;
      gap: 8px;
      align-items:center;
      padding: 8px 6px;
      border-bottom: 1px solid rgba(255,255,255,0.10);
      font-size: 13px;
    }
    .lb-head{
      position: sticky;
      top: 0;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      border-radius: 10px;
      border-bottom: 1px solid rgba(255,255,255,0.14);
      font-weight: 900;
      z-index: 2;
    }
    .lb-me{ background: rgba(78,204,163,0.20); border-radius: 10px; }

    #ov-fx{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:none;
    }

        /* âœ… Breakdown list */
    #ov-breakdown{
      margin: 8px 0 10px 0;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
    }
    .bd-row{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      padding: 6px 4px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      opacity: 0.72;
    }
    .bd-row:last-child{ border-bottom:none; }

    .bd-lbl{
      font-size: 12px;
      letter-spacing: 0.6px;
      text-transform: uppercase;
      color: rgba(255,255,255,0.82);
    }
    .bd-val{
      font-size: 14px;
      font-weight: 900;
      color: rgba(255,209,102,0.95);
      text-shadow: 0 0 14px rgba(255,209,102,0.22);
    }

    .bd-row.active{
      opacity: 1;
    }
    .bd-row.active .bd-lbl{ color: rgba(255,255,255,0.95); }
    .bd-row.active .bd-val{ color: rgba(255,209,102,1); }

    /* âœ… flying ghost */
    .ov-ghost{
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.35);
      color: rgba(255,255,255,0.95);
      font-weight: 900;
      box-shadow: 0 14px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
      transform: translate(-50%, -50%);
    }
  </style>
</head>

<body>
  <div id="ui">
    <div id="hud-top">
      <div class="stat-card">
        <div class="label">åˆ†æ•¸</div>
        <div id="score" class="value">0</div>
      </div>
      <div class="stat-card">
        <div class="label">å±¤æ•¸</div>
        <div id="level" class="value">0</div>
      </div>
      <div class="stat-card">
        <div class="label">Combo</div>
        <div id="combo" class="value">0</div>
      </div>
    </div>

    <!-- âœ… TIME ä¸‹æ–¹æ”¹æˆä¸€è¡Œï¼šå·¦ Roundã€å³ Time -->
    <div id="hud-bottom">
      <div class="stat-card" id="round-card">
        <div class="label">ç›®å‰å›åˆ</div>
        <div id="round-text" class="value">1/3</div>
      </div>

      <div class="stat-card" id="timer-card">
        <div class="label">æ™‚é–“</div>
        <div id="timer-text" class="value">8.0</div>
        <div id="timer-bar"><div id="timer-fill"></div></div>
      </div>
    </div>
  </div>

  <div id="login" class="show" aria-hidden="false">
    <div class="backdrop"></div>
    <div class="panel" role="dialog" aria-modal="true">
      <h1 style="margin:2px 0 8px 0;font-size:40px;font-weight:900;color:#fff;">å»ºç¯‰å¤§å¸«V2.20ç‰ˆ</h1>
      <p style="margin:0 0 10px 0;color:rgba(255,255,255,0.9);">è¼¸å…¥ç©å®¶IDï¼Œé™ 6 å€‹ä¸­æ–‡å­—</p>
      <input id="player-id-input" maxlength="6"
        style="width:100%;box-sizing:border-box;border-radius:14px;padding:12px 14px;border:1px solid rgba(255,255,255,0.25);background:rgba(0,0,0,0.25);color:#fff;font-size:18px;font-weight:900;outline:none;"
        placeholder="ä¾‹å¦‚ï¼šä¸­å’Œé„­å…ˆç”Ÿ" />

      <div id="login-err" style="margin-top:8px;color:#ffb3c1;font-weight:900;min-height:22px;"></div>

      <button id="btn-login" type="button" style="width:100%;margin-top:8px;">é€²å…¥éŠæˆ²</button>
      <p style="margin:0 0 0px 0;color:rgba(255,255,255,0.9);">â€»éŠæˆ²å…±3å€‹å›åˆ</p>
      <p style="margin:0 0 0px 0;color:rgba(255,255,255,0.9);">â€»é€£çºŒCOMBOè¶Šå¤šï¼è¶Šé«˜åˆ†</p>
      <p style="margin:0 0 0px 0;color:rgba(255,255,255,0.9);">â€»è“‹çš„æ¨“å±¤è¶Šé«˜ï¼è¶Šé«˜åˆ†</p>
    </div>
</div>

  <div id="overlay" aria-hidden="true" inert>
      <div class="backdrop"></div>
      <div class="panel" role="dialog" aria-modal="true" id="ov-panel">
        <canvas id="ov-fx"></canvas>

        <h1 id="ov-title">å»ºç¯‰ç‰©å€’å¡Œ</h1>
        <p id="ov-sub">æ­£åœ¨å´©å¡Œä¸­â€¦</p>

        <!-- âœ… Round1/2 ç”¨ ROUND SCOREï¼›Round3 ä¿ç•™ TOTAL å¦å€å¡Š -->
        <div id="ov-main-score">
          <div class="k" id="ov-main-k">ROUND SCORE</div>
          <div class="v" id="ov-main-v">0</div>
        </div>

        <div id="ov-total-big">
          <div class="k">æœ¬æ¬¡éŠæˆ²ç¸½åˆ†</div>
          <div class="v" id="ov-total-big-v">0</div>
        </div>

        <!-- âœ… åŠ æ¬Šæ‹†è§£ï¼ˆLEVEL/SCORE/COMBO çš„è²¢ç»ï¼‰ -->
        <div id="ov-breakdown" style="display:none;">
          <div class="bd-row" id="bd-row-1">
            <span class="bd-lbl" id="bd-lbl-1">å±¤æ•¸ Ã— 100</span>
            <span class="bd-val" id="bd-val-1">+0</span>
          </div>
          <div class="bd-row" id="bd-row-2">
            <span class="bd-lbl" id="bd-lbl-2">åˆ†æ•¸ Ã— 5</span>
            <span class="bd-val" id="bd-val-2">+0</span>
          </div>
          <div class="bd-row" id="bd-row-3">
            <span class="bd-lbl" id="bd-lbl-3">ç´¯ç©COMBOæ•¸ Ã— 50</span>
            <span class="bd-val" id="bd-val-3">+0</span>
          </div>
        </div>

        <!-- âœ… çµç®—ä¸‹æ’ä¸‰å¡ï¼šLEVEL / SCORE / COMBOï¼ˆRound1/2/3 å…¨éƒ½ç”¨é€™æ’ï¼‰ -->
        <div class="summary r3" id="ov-summary" style="display:none;">
          <div class="card" id="ov-card-1"><div class="k">å±¤æ•¸</div><div class="v" id="ov-height">0</div></div>
          <div class="card" id="ov-card-2"><div class="k">åˆ†æ•¸</div><div class="v" id="ov-score">0</div></div>
          <div class="card" id="ov-card-3"><div class="k">ç´¯ç©COMBO</div><div class="v" id="ov-combo">0</div></div>
        </div>

        <div class="actions" id="ov-actions" style="display:none;">
          <button id="btn-retry" type="button">å†ç©ä¸€æ¬¡</button>
        </div>

        <div class="leaderboard" id="lb-wrap" style="display:none;">
          <div class="lb-title">æ’è¡Œæ¦œ</div>
          <div class="lb-sub" id="lb-sub">æ’åºï¼šç¸½åˆ†ï¼ˆåŒåˆ†å…ˆå®Œæˆè€…å„ªå…ˆï¼‰</div>
          <div class="lb-scroll" id="lb-scroll" role="region" aria-label="leaderboard">
            <div class="lb-row lb-head"><div>#</div><div>ç©å®¶ID</div><div>ç¸½åˆ†</div></div>
            <div id="lb-list"></div>
          </div>
        </div>

      </div>
  </div>

  <div id="game-viewport"></div>

<script type="module">

// ğŸ”¥ å…ˆ import Firebase
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-app.js";
import {
  getFirestore, collection, addDoc, serverTimestamp,
  query, orderBy, limit, getDocs
} from "https://www.gstatic.com/firebasejs/12.9.0/firebase-firestore.js";
import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.9.0/firebase-auth.js";

// Firebase åˆå§‹åŒ–
const firebaseConfig = {
  apiKey: "AIzaSyASYxPS3KfIF9khcMwukfxYdVosdN7Qj_Y",
  authDomain: "game-buildhouse.firebaseapp.com",
  projectId: "game-buildhouse",
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

try {
  await signInAnonymously(auth);
} catch (e) {
  console.error("Anonymous auth failed. Did you enable it in Firebase Console?", e);
}

// å¦‚æœä½ å¾Œé¢è¦ç”¨
window.__db = db;
window.__auth = auth;

const { Engine, Render, Runner, World, Bodies, Body, Events, Constraint } = Matter;

/* =========================
   Firestore helpersï¼ˆâ­é€™è£¡ï¼‰
========================= */
async function fetchTopScores(){
  const db = window.__db;
  if(!db) return [];

  const q = query(
    collection(db, "leaderboard"),
    orderBy("total", "desc"),
    orderBy("tsEnd", "asc"),
    limit(30)
  );
  const snap = await getDocs(q);
  return snap.docs.map(d => d.data());
}

/* =========================
   Engine / Render
========================= */
const engine = Engine.create();
const world = engine.world;

engine.enableSleeping = true;

engine.positionIterations = 10;
engine.velocityIterations = 8;
engine.constraintIterations = 4;
world.gravity.y = 1;

let viewW = window.innerWidth;
let viewH = window.innerHeight;
let WORLD_HEIGHT = viewH * 60;

const viewport = document.getElementById('game-viewport');
const render = Render.create({
  element: viewport,
  engine,
  options: { width: viewW, height: viewH, wireframes: false, background: 'transparent', hasBounds: true }
});
Render.setPixelRatio(render, window.devicePixelRatio || 1);

/* =========================
   UI refs
========================= */
const login = document.getElementById('login');
const idInput = document.getElementById('player-id-input');
const loginErr = document.getElementById('login-err');
const btnLogin = document.getElementById('btn-login');
const overlay = document.getElementById('overlay');
const ovTitle = document.getElementById('ov-title');
const ovSub = document.getElementById('ov-sub');
const ovSummary = document.getElementById('ov-summary');
const ovHeight = document.getElementById('ov-height');
const ovScore = document.getElementById('ov-score');
const ovCombo = document.getElementById('ov-combo');
const ovActions = document.getElementById('ov-actions');
const btnRetry = document.getElementById('btn-retry');
const timerCard = document.getElementById('timer-card');

const roundText = document.getElementById('round-text');

const ovPanel = document.getElementById('ov-panel');
const ovTotalBig = document.getElementById('ov-total-big');
const ovTotalBigV = document.getElementById('ov-total-big-v');
const ovMainScore = document.getElementById('ov-main-score');
const ovMainK = document.getElementById('ov-main-k');
const ovMainV = document.getElementById('ov-main-v');

const ovCard1 = document.getElementById('ov-card-1');
const ovCard2 = document.getElementById('ov-card-2');
const ovCard3 = document.getElementById('ov-card-3');

const ovFx = document.getElementById('ov-fx');

// âœ… breakdown refs
const ovBreakdown = document.getElementById('ov-breakdown');
const bdRow1 = document.getElementById('bd-row-1');
const bdRow2 = document.getElementById('bd-row-2');
const bdRow3 = document.getElementById('bd-row-3');
const bdVal1 = document.getElementById('bd-val-1');
const bdVal2 = document.getElementById('bd-val-2');
const bdVal3 = document.getElementById('bd-val-3');

/* =========================
   Login Validation
========================= */

function isCjkHan(str){
  return /^[\u4E00-\u9FFF]+$/.test(str);
}

function validatePlayerId(raw){
  const s = (raw || "").trim();
  if(!s) return { ok:false, msg:"è«‹è¼¸å…¥ID" };
  if(s.length > 6) return { ok:false, msg:"æœ€å¤š 6 å€‹å­—" };
  if(!isCjkHan(s)) return { ok:false, msg:"åªèƒ½è¼¸å…¥ä¸­æ–‡å­—" };
  return { ok:true, id:s };
}

/* =========================
   ä¸‰å›åˆè³½åˆ¶
========================= */
const ROUND_COUNT = 3;
const ROUND_TIMES = [12, 8, 6];
let roundIndex = 1;
let roundTime = ROUND_TIMES[0];

let runId = "";
let playerId = "-";
let tsStart = 0;
let tsEnd = 0;

let roundScores = [0,0,0];
let totalPerfect = 0;

function setRoundHUD(){
  if(roundText) roundText.textContent = `${roundIndex}/${ROUND_COUNT}`;
}
function getRoundTime(idx){ return ROUND_TIMES[Math.max(1, Math.min(ROUND_COUNT, idx)) - 1]; }
function computeRoundScore(){
  return (level*100) + (score*5) + (totalPerfect*50);
}
function lockActionButton(lock){
  if(!btnRetry) return;
  btnRetry.disabled = !!lock;
}

/* =========================
   Flash helper
========================= */
function flashOnce(el){
  if(!el) return;
  el.classList.remove('flash-once');
  void el.offsetWidth;
  el.classList.add('flash-once');
}

/* =========================
   Count up helper
========================= */
function animateNumber(el, from, to, durMs){
  return new Promise((resolve)=>{
    const start = performance.now();
    const a = Number(from) || 0;
    const b = Number(to) || 0;
    const D = Math.max(120, durMs|0);

    function step(now){
      const t = Math.min(1, (now - start) / D);
      const te = t*t*(3-2*t);
      const v = Math.round(a + (b - a) * te);
      el.textContent = String(v);
      if(t < 1) requestAnimationFrame(step);
      else resolve();
    }
    requestAnimationFrame(step);
  });
}

/* =========================
   Overlay FX (clean particles)
========================= */
let fxRAF = 0;
let fxParticles = [];

function resizeFxCanvas(){
  if(!ovFx || !ovPanel) return;
  const r = ovPanel.getBoundingClientRect();
  const dpr = (window.devicePixelRatio||1);
  ovFx.width  = Math.max(2, Math.floor(r.width * dpr));
  ovFx.height = Math.max(2, Math.floor(r.height * dpr));
  ovFx.style.width = r.width + "px";
  ovFx.style.height = r.height + "px";
}
function spawnFxBurst(){
  const dpr = (window.devicePixelRatio||1);
  const w = ovFx.width, h = ovFx.height;

  const cx = w * (0.35 + Math.random()*0.30);
  const cy = h * (0.22 + Math.random()*0.22);

  const count = 26 + Math.floor(Math.random()*22); // ç²’å­æ›´å¤š
  for(let i=0;i<count;i++){
    const a = Math.random() * Math.PI * 2;
    const sp = (2.4 + Math.random()*5.2) * dpr * 0.4; // å™´æ›´å¿«ã€æ›´æ“´æ•£
    fxParticles.push({
      x: cx, y: cy,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - 1.6*dpr*0.35,
      life: 0.5 + Math.random()*0.35,
      r: 2.4 * dpr * 0.75  // ç²’å­æ›´å¤§é¡†
    });
  }
}
function startOverlayParticlesBurst(bursts=2){
  if(!ovFx) return;

  cancelAnimationFrame(fxRAF);
  fxParticles.length = 0;

  ovFx.style.display = "block";
  resizeFxCanvas();

  for(let i=0;i<bursts;i++){
    setTimeout(spawnFxBurst, i*140);
  }

  const ctx = ovFx.getContext('2d');
  const dpr = (window.devicePixelRatio||1);

  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000);
    last = now;

    ctx.clearRect(0,0,ovFx.width,ovFx.height);

    for(let i=fxParticles.length-1;i>=0;i--){
      const p = fxParticles[i];
      p.life -= dt;
      if(p.life <= 0){ fxParticles.splice(i,1); continue; }

      p.vy += 8 * dt * dpr * 0.35;

      p.x += p.vx;
      p.y += p.vy;

      p.vx *= 0.98;
      p.vy *= 0.98;

      const alpha = Math.max(0, Math.min(1, p.life / 0.85));
      ctx.globalAlpha = alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255, 209, 102, 1)";
      ctx.fill();
    }

    ctx.globalAlpha = 1;

    if(fxParticles.length > 0){
      fxRAF = requestAnimationFrame(tick);
    }else{
      ctx.clearRect(0,0,ovFx.width,ovFx.height);
      ovFx.style.display = "none";
      cancelAnimationFrame(fxRAF);
      fxRAF = 0;
    }
  }

  fxRAF = requestAnimationFrame(tick);
}

    function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

    function resetBreakdown(){
      if(!ovBreakdown) return;
      ovBreakdown.style.display = "block";
      if(bdVal1) bdVal1.textContent = "+0";
      if(bdVal2) bdVal2.textContent = "+0";
      if(bdVal3) bdVal3.textContent = "+0";
      if(bdRow1) bdRow1.classList.remove('active');
      if(bdRow2) bdRow2.classList.remove('active');
      if(bdRow3) bdRow3.classList.remove('active');
    }

    function setActiveRow(rowEl){
      if(bdRow1) bdRow1.classList.remove('active');
      if(bdRow2) bdRow2.classList.remove('active');
      if(bdRow3) bdRow3.classList.remove('active');
      if(rowEl) rowEl.classList.add('active');
    }

    // âœ… "+1234" è·‘å‹•ï¼ˆå«æ­£è² ï¼Œä½†ä½ é€™è£¡éƒ½æ­£ï¼‰
    function animatePlus(el, from, to, durMs){
      return new Promise((resolve)=>{
        const start = performance.now();
        const a = Number(from) || 0;
        const b = Number(to) || 0;
        const D = Math.max(160, durMs|0);

        function step(now){
          const t = Math.min(1, (now - start) / D);
          const te = t*t*(3-2*t);
          const v = Math.round(a + (b - a) * te);
          el.textContent = `+${v}`;
          if(t < 1) requestAnimationFrame(step);
          else resolve();
        }
        requestAnimationFrame(step);
      });
    }

    // âœ… ghost å¾ fromEl é£›åˆ° toEl
    function flyGhost(fromEl, toEl, text){
      return new Promise((resolve)=>{
        if(!fromEl || !toEl){
          resolve();
          return;
        }
        const fr = fromEl.getBoundingClientRect();
        const tr = toEl.getBoundingClientRect();

        const ghost = document.createElement('div');
        ghost.className = "ov-ghost";
        ghost.textContent = text;

        // èµ·é»ï¼šfromEl ä¸­å¿ƒ
        ghost.style.left = (fr.left + fr.width/2) + "px";
        ghost.style.top  = (fr.top  + fr.height/2) + "px";
        ghost.style.opacity = "1";
        ghost.style.transition = "transform 320ms cubic-bezier(.2,.9,.2,1), opacity 320ms ease";

        document.body.appendChild(ghost);

        // ä¸‹ä¸€å¹€å†ç§»å‹•åˆ°çµ‚é»
        requestAnimationFrame(()=>{
          const dx = (tr.left + tr.width/2) - (fr.left + fr.width/2);
          const dy = (tr.top  + tr.height/2) - (fr.top  + fr.height/2);
          ghost.style.transform = `translate(${dx}px, ${dy}px) scale(0.86)`;
          ghost.style.opacity = "0.92";
        });

        setTimeout(()=>{
          ghost.remove();
          resolve();
        }, 340);
      });
    }

/* =========================
   âœ… çµç®—è·‘å‹•ï¼šRound1/2 ä¸»å¡æ˜¯ ROUND SCOREï¼›Round3 ä¸»å¡æ˜¯ TOTAL
   - Round1/2ï¼šROUND SCORE -> flash + particlesï¼›å†è·‘ LEVEL/SCORE/COMBO ä¸‰å¡ï¼ˆæ¯å¡çµæŸ flashï¼‰
   - Round2ï¼šæœ€å¾ŒæŠŠ ROUND SCORE label æ›æˆ CUMULATIVEï¼Œæ•¸å­—å¾æœ¬å›åˆ -> ç´¯ç©ï¼ˆåŸè¦æ ¼ä¿ç•™ï¼‰
   - Round3ï¼šTOTAL èµ° ov-total-bigï¼ˆä¿ç•™ä½ è¦çš„ã€Œæ¨™é¡Œä¸‹æ–¹ã€ï¼‰ï¼Œè·‘å®Œ flash
========================= */
async function runSummaryCountUp({ isLast, roundScore, totalScore, showCumulativeAfterRound2 }){
  lockActionButton(true);

  // âœ… ä¸‰å¡ç›´æ¥é¡¯ç¤ºæœ€çµ‚å€¼ï¼ˆä¸è·‘å‹•ï¼‰
  ovHeight.textContent = String(level);
  ovScore.textContent  = String(score);
  ovCombo.textContent  = String(totalPerfect);

  // âœ… breakdown reset / show
  resetBreakdown();

  // âœ… é¸ç›®æ¨™ï¼šRound1/2 ç”¨ ovMainVï¼›Round3 ç”¨ ovTotalBigV
  const targetV = isLast ? ovTotalBigV : ovMainV;
  const targetWrap = isLast ? ovTotalBig : ovMainScore; // ç”¨ä¾† flash
  if(targetV) targetV.textContent = "0";

  // âœ… å…ˆæŠŠ breakdown å€¼æ­¸é›¶ï¼Œä¸»åˆ†æ•¸ä¹Ÿå¾ 0 é–‹å§‹è·‘ç´¯åŠ 
  let running = 0;
  const vLevel = level;
  const vScore = score;
  const vCombo = totalPerfect;

  const c1 = vLevel * 100;
  const c2 = vScore * 5;
  const c3 = vCombo * 50;
  const final = isLast ? totalScore : roundScore; // roundScore ä½ å¤–é¢å·²ç®—å¥½

  // âš ï¸ ä¿éšªï¼šå¦‚æœ roundScore/totalScore ä¸æ˜¯ç”±é€™ä¸‰é …æ§‹æˆï¼ˆæœªä¾†ä½ åŠ åˆ¥é …ï¼‰ï¼Œé€™è£¡ä»¥å‚³å…¥å€¼ç‚ºæº–
  // ä½†è·‘å‹•ä»ç”¨ c1/c2/c3 ç´¯åŠ ï¼›æœ€å¾Œå¼·åˆ¶æŠŠä¸»åˆ†æ•¸çŸ¯æ­£åˆ° finalã€‚
  async function applyPart({ fromEl, rowEl, bdEl, contrib }){
    setActiveRow(rowEl);

    // 1) ghost é£›
    await flyGhost(fromEl, targetV, String(fromEl.textContent || ""));

    // 2) breakdown è¡Œ +xxxx è·‘å‹•
    if(bdEl) bdEl.textContent = "+0";

    const prevRunning = running;
    const nextRunning = running + contrib;

    // breakdown + ä¸»åˆ†æ•¸ åŒæ­¥è·‘å‹•ï¼ˆä¸»åˆ†æ•¸é¡¯ç¤ºç´¯åŠ ä¸­ï¼‰
    await Promise.all([
      bdEl ? animatePlus(bdEl, 0, contrib, 520) : Promise.resolve(),
      targetV ? animateNumber(targetV, prevRunning, nextRunning, 520) : Promise.resolve()
    ]);

    running = nextRunning;

    // å°åœé “ + flash ä¸€ä¸‹è©²è¡Œï¼ˆç”¨ä½ ç¾æˆå¡ç‰‡ flash ä¹Ÿè¡Œï¼Œä½†é€™è£¡åªäº® rowï¼‰
    await sleep(90);
  }

  // âœ… ä¾åºï¼šLEVEL â†’ SCORE â†’ COMBO
  await applyPart({ fromEl: ovHeight, rowEl: bdRow1, bdEl: bdVal1, contrib: c1 });
  await applyPart({ fromEl: ovScore,  rowEl: bdRow2, bdEl: bdVal2, contrib: c2 });
  await applyPart({ fromEl: ovCombo,  rowEl: bdRow3, bdEl: bdVal3, contrib: c3 });

  // âœ… æœ€çµ‚çŸ¯æ­£åˆ° roundScore / totalScoreï¼ˆé¿å…æœªä¾†åŠ é …æˆ–å››æ¨äº”å…¥é€ æˆå·®ï¼‰
  if(targetV && running !== final){
    await animateNumber(targetV, running, final, 320);
    running = final;
  }

  // âœ… å®Œæˆï¼šflash + ç²’å­ burstï¼ˆä½ è¦çš„ï¼‰
  flashOnce(targetWrap);
  startOverlayParticlesBurst(3);
  await sleep(120);

  // âœ… Round2ï¼šåš cumulative éå ´ï¼ˆåŸè¦æ ¼ä¿ç•™ï¼‰
  if(!isLast && showCumulativeAfterRound2){
    await sleep(220);

    const from = final; // Round2 çš„ roundScore
    const to = (roundScores[0]||0) + (roundScores[1]||0);

    ovMainK.textContent = "ç´¯ç©åˆ†æ•¸";

    // é€™æ®µä¸éœ€è¦ breakdown å†è·‘ï¼›ä½ è¦çš„æ˜¯ã€Œæ–‡å­—å‹•ç•«è®Šæˆç´¯ç©åˆ†ã€
    setActiveRow(null);
    if(ovBreakdown) ovBreakdown.style.display = "none";

    ovMainV.textContent = String(from);
    await animateNumber(ovMainV, from, to, 880);

    flashOnce(ovMainScore);
  }

  lockActionButton(false);
}

/* =========================
   Tunables / game (ä¿ç•™ä½ åŸæœ¬)
========================= */
function relaxFactor(){
  const tRaw = (level - 10) / 51;
  const t = Math.max(0, Math.min(1, tRaw));
  const te = t * t * (3 - 2 * t);
  return 1.0 + 0.25 * te;
}
const MAX_LEVEL = 61;

const BASE_ANCHOR = {
  friction: 2.2,
  frictionStatic: 3.6,
  frictionAir: 0.12,
  angDamp: 0.55,   // è§’é€Ÿåº¦å†ç ä¸€é»
  velXDamp: 0.25   // X é€Ÿåº¦ç ä¸€é»ï¼ˆé˜²æ­¢æ…¢æ…¢æ»‘ï¼‰
};

const MATERIAL = {
  restitution: 0.00,
  friction: 0.95,
  frictionStatic: 1.00,
  frictionAir: 0.03,
  density: 0.0022
};

const LANDING_STABILIZE = {
  frictionAirBoost: 0.20,
  durationMs: 150,
  velXScale: 0.03,
  velYScale: 0.40,
  angScale: 0.16
};

const STABILITY = { windowMs:240, maxAngleRad:0.78, maxOmega:2.35, maxYDrop:105, maxXDrift:120 };
const COLLAPSE  = { holdMs:360, angleRad:1.1, omega:3.15, speed:8.4, xPadding:280 };
const FAIL = { outOfViewPadding:220, outOfWorldPadding:600, xPadding:240 };
const GAMEOVER = { removeGroundMs:350, showSummaryMs:1150 };

/* =========================
   UI Safe Zone
========================= */
let uiBottomPx = 170;
const UI_SAFE = { topPad: 22, craneMargin: 14 };
function measureUiBottom(){
  const ui = document.getElementById('ui');
  if(!ui) return;
  const r = ui.getBoundingClientRect();
  uiBottomPx = Math.ceil(r.bottom);
}

/* =========================
   Block sizing
========================= */
const BASE_W = 84;
const BASE_H = 56;

function scaleForLevel(lvl){
  if(lvl <= 10) return 1.0;
  if(lvl <= 20) return 0.82;
  if(lvl <= 30) return 0.64;
  if(lvl <= 40) return 0.46;
  if(lvl <= 50) return 0.28;
  if(lvl <= 60) return 0.14;
  return 0.14;
}
function sizeForLevel(lvl){
  const s = scaleForLevel(lvl);
  const w = Math.max(14, BASE_W * s);
  const h = Math.max(9,  BASE_H * s);
  return { w, h, s };
}

/* =========================
   åŠå°å­˜
========================= */
function segmentIdForLevel(lvl){
  if(lvl <= 10) return 0;
  if(lvl <= 20) return 1;
  if(lvl <= 30) return 2;
  if(lvl <= 40) return 3;
  if(lvl <= 50) return 4;
  return 5;
}
const SEAL = {
  keepTop: 14,
  frictionAir: 0.18,
  velScale: 0.25,
  angScale: 0.20,
  continuousDamp: true,
  perFrameVelScale: 0.988,
  perFrameAngScale: 0.985
};
const stackedBlocks = [];
function getActiveBlocks(){
  return stackedBlocks.slice(Math.max(0, stackedBlocks.length - SEAL.keepTop));
}
function sealOldSegment(){
  const cutoff = Math.max(0, stackedBlocks.length - SEAL.keepTop);
  const now = engine.timing.timestamp;

  for(let i=0;i<cutoff;i++){
    const b = stackedBlocks[i];
    b.plugin = b.plugin || {};
    if(b.plugin.sealed) continue;

    b.plugin.sealed = true;
    b.plugin.sealedAt = now;
    b.plugin.lockX = b.position.x;

    b.frictionAir = Math.max(b.frictionAir, SEAL.frictionAir);
    Body.setVelocity(b, { x: b.velocity.x * SEAL.velScale, y: b.velocity.y * SEAL.velScale });
    Body.setAngularVelocity(b, b.angularVelocity * SEAL.angScale);
  }
}

function dampSealedBlocks(){
  if(!SEAL.continuousDamp) return;
  const cutoff = Math.max(0, stackedBlocks.length - SEAL.keepTop);

  const LOCK_POS_LERP = 0.22;
  const LOCK_VEL_DAMP = 0.00;

  for(let i=0;i<cutoff;i++){
    const b = stackedBlocks[i];
    if(!b.plugin?.sealed) continue;

    Body.setVelocity(b, {
      x: b.velocity.x * SEAL.perFrameVelScale,
      y: b.velocity.y * SEAL.perFrameVelScale
    });
    Body.setAngularVelocity(b, b.angularVelocity * SEAL.perFrameAngScale);

    const lockX = (typeof b.plugin.lockX === "number") ? b.plugin.lockX : b.position.x;
    const dx = lockX - b.position.x;

    Body.setVelocity(b, { x: b.velocity.x * LOCK_VEL_DAMP, y: b.velocity.y });

    if(Math.abs(dx) > 0.01){
      Body.setPosition(b, { x: b.position.x + dx * LOCK_POS_LERP, y: b.position.y });
    }
  }
}

/* =========================
   Ground
========================= */
let groundY = WORLD_HEIGHT - 60;
const groundH = 100;
let ground = Bodies.rectangle(viewW/2, groundY, viewW, groundH, {
  isStatic: true,
  restitution: 0.0,
  friction: 1.0,
  frictionStatic: 1.0,
  render: { visible:false }
});
World.add(world, ground);

/* =========================
   Camera
========================= */
const CAMERA = {
  smoothUp: 0.18,
  bottomPad: 30
};

let cameraTargetY = 0;
let currentScrollY = 0;
let skyScrollY = 0;

/* =========================
   Crane
========================= */
const CRANE = {
  radius: 150,
  gapMin: 110,
  gapMax: 150
};

let currentCraneBlock = null;
let fallingBlock = null;
let pendingCommit = null;

let swingTime = 0;
const craneRadius = CRANE.radius;
let cranePivotX = 0;
let cranePivotY = 0;

let state = "running";
let didFirstLandFX = false;
// camera shake
let shakeMs = 0;
let shakeAmp = 0;
let shakeT = 0;
let endReason = "";
let score = 0, level = 0, combo = 0, timeLeft = 0;
let inputLock = false;
let spawnQueued = false;
let collapseBadMs = 0;
let lastTimestamp = null;

const particles = [];
const popups = [];

function getTowerTopWorldY(){
  let topY = Infinity;
  for(const b of stackedBlocks) topY = Math.min(topY, b.bounds.min.y);
  if(!isFinite(topY)) topY = groundY - 180;
  return topY;
}
function getTopMostWorldY(){
  let topY = getTowerTopWorldY();
  if(currentCraneBlock) topY = Math.min(topY, currentCraneBlock.bounds.min.y);
  if(fallingBlock) topY = Math.min(topY, fallingBlock.bounds.min.y);
  if(pendingCommit?.body) topY = Math.min(topY, pendingCommit.body.bounds.min.y);
  return topY;
}

function computeCameraTargetFromSafeTop(){
  measureUiBottom();

  const topMostY = getTopMostWorldY();
  const desiredTopOnScreen = uiBottomPx + UI_SAFE.topPad + UI_SAFE.craneMargin;
  let targetY = topMostY - desiredTopOnScreen;

  const minY = Math.max(0, groundY - viewH + CAMERA.bottomPad);
  const maxY = Math.max(0, WORLD_HEIGHT - viewH);

  targetY = Math.max(targetY, minY);
  targetY = Math.min(targetY, maxY);

  return targetY;
}

function applyCamera(){
  const y = Math.max(0, Math.min(WORLD_HEIGHT - viewH, currentScrollY));

  // shake offsetï¼ˆåªå½±éŸ¿éŠæˆ²ç•«é¢ï¼Œä¸å‹• UIï¼‰
  let ox = 0, oy = 0;
  if(shakeMs > 0){
    // å°å¹…ã€å¿«é€Ÿã€è¡°æ¸›
    ox = (Math.random()*2-1) * shakeAmp;
    oy = (Math.random()*2-1) * shakeAmp * 0.6;
  }

  render.bounds.min.x = 0 + ox;
  render.bounds.max.x = viewW + ox;
  render.bounds.min.y = y + oy;
  render.bounds.max.y = y + viewH + oy;
}

function initCamera(){
  const startY = Math.max(0, groundY - viewH + CAMERA.bottomPad);
  cameraTargetY = startY;
  currentScrollY = startY;
  skyScrollY = startY;
  applyCamera();
}

function updateCamera(){
  const safetyTarget = computeCameraTargetFromSafeTop();
  if(safetyTarget < cameraTargetY) cameraTargetY = safetyTarget;

  if(cameraTargetY < currentScrollY){
    currentScrollY = currentScrollY + (cameraTargetY - currentScrollY) * CAMERA.smoothUp;
  }
  skyScrollY = skyScrollY + (currentScrollY - skyScrollY) * 0.08;
  applyCamera();
}

function startShake(ms=180, amp=6){
  shakeMs = ms;
  shakeAmp = amp;
  shakeT = 0;
}

/* =========================
   Background
========================= */
function lerp(a,b,t){ return a + (b-a)*t; }
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function hexToRgb(hex){
  const h = hex.replace('#','');
  const n = parseInt(h.length===3 ? h.split('').map(c=>c+c).join('') : h, 16);
  return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
}
function rgbToCss({r,g,b}){ return `rgb(${r|0},${g|0},${b|0})`; }
function mix(c1,c2,t){
  const a = hexToRgb(c1), b = hexToRgb(c2);
  return rgbToCss({ r:lerp(a.r,b.r,t), g:lerp(a.g,b.g,t), b:lerp(a.b,b.b,t) });
}
const BG_STOPS = [
  { lvl: 0,  top:"#87CEEB", bottom:"#cfefff" },
  { lvl: 8,  top:"#6fc3ff", bottom:"#c8f0ff" },
  { lvl: 16, top:"#2f7be6", bottom:"#90d6ff" },
  { lvl: 24, top:"#1a1a2e", bottom:"#15406f" },
  { lvl: 32, top:"#0c0c18", bottom:"#0e2a45" },
  { lvl: 40, top:"#050505", bottom:"#0b1a2e" }
];

// âœ… Round èƒŒæ™¯ä¸»é¡Œï¼š1=åŸæœ¬ä¾ levelã€2=é»ƒæ˜ã€3=å¤œæ™šæ˜Ÿç©º
let bgTheme = "level"; // "level" | "dusk" | "night"

function applyRoundBackground(){
  if(roundIndex === 2){
    bgTheme = "dusk";
    // é»ƒæ˜ï¼šæ©˜ç´«åˆ°æ·±è—
    document.body.style.background = "linear-gradient(#ffb56b, #6a4c93, #1b2a49)";
  }else if(roundIndex === 3){
    bgTheme = "night";
    // å¤œæ™šï¼šæ·±è—åˆ°æ›´æ·±
    document.body.style.background = "linear-gradient(#050b2e, #020517)";
  }else{
    bgTheme = "level";
    // Round1 ç…§ä½ åŸæœ¬çš„ level å‹•æ…‹èƒŒæ™¯
    setBackgroundForLevelSmooth(level);
  }
}

function setBackgroundForLevelSmooth(lvl){
  // âœ… Round2/3 å›ºå®šèƒŒæ™¯ï¼Œä¸è¦è¢« level è®Šå‹•è¦†è“‹
  if(bgTheme !== "level") return;

  let i = 0;
  while(i < BG_STOPS.length-1 && lvl > BG_STOPS[i+1].lvl) i++;
  const a = BG_STOPS[i];
  const b = BG_STOPS[Math.min(i+1, BG_STOPS.length-1)];
  const span = Math.max(1, b.lvl - a.lvl);
  const t = clamp01((lvl - a.lvl) / span);
  const top = mix(a.top, b.top, t);
  const bot = mix(a.bottom, b.bottom, t);
  document.body.style.background = `linear-gradient(${top}, ${bot})`;
}

/* =========================
   UI
========================= */
function updateUI(){
  document.getElementById('score').innerText = score;
  document.getElementById('level').innerText = level;
  document.getElementById('combo').innerText = combo;
}
function updateTimerUI(){
  const t = Math.max(0, timeLeft);
  document.getElementById('timer-text').innerText = t.toFixed(1);
  document.getElementById('timer-fill').style.width = (t / roundTime * 100) + "%";

  if(timerCard){
    if(state === "running" && level > 0 && t <= 3.0 && t > 0) timerCard.classList.add('time-warn');
    else timerCard.classList.remove('time-warn');
  }
}

function showOverlayCollapsing(reasonText){
  overlay.classList.add('show');
  overlay.removeAttribute('inert'); 
  overlay.setAttribute('aria-hidden','false');
  ovTitle.textContent = "å»ºç¯‰ç‰©å€’å¡Œ";
  ovSub.textContent = reasonText + "ï¼ˆå´©å¡Œä¸­â€¦ï¼‰";
  ovSummary.style.display = "none";
  ovActions.style.display = "none";
  if(ovTotalBig) ovTotalBig.style.display = "none";
  if(ovMainScore) ovMainScore.style.display = "none";
  const lb = document.getElementById('lb-wrap');
  if(lb) lb.style.display = "none";
}

function showOverlaySummaryBase({ titleText, subText, buttonText, showLB, isLastRound }){
  overlay.classList.add('show');
  overlay.removeAttribute('inert');
  overlay.setAttribute('aria-hidden','false');

  ovTitle.textContent = titleText;
  ovSub.textContent = subText;

  btnRetry.textContent = buttonText;

  ovSummary.style.display = "grid";
  ovActions.style.display = "block";

  // âœ… Round1/2 ä¹Ÿæ”¹æˆã€Œä¸»å¡åœ¨ä¸Š + ä¸‰å¡åœ¨ä¸‹ã€
  if(isLastRound){
    if(ovMainScore) ovMainScore.style.display = "none";
    if(ovTotalBig) ovTotalBig.style.display = "block";
  }else{
    if(ovTotalBig) ovTotalBig.style.display = "none";
    if(ovMainScore) ovMainScore.style.display = "block";
    ovMainK.textContent = "æœ¬å›åˆåˆ†æ•¸";
  }

  const lb = document.getElementById('lb-wrap');
  if(lb) lb.style.display = showLB ? "block" : "none";

  btnRetry.style.pointerEvents = "auto";
  ovActions.style.pointerEvents = "auto";

  if(ovFx){
    ovFx.style.display = "none";
    const ctx = ovFx.getContext('2d');
    if(ctx) ctx.clearRect(0,0,ovFx.width,ovFx.height);
  }

  // âœ… breakdown é è¨­é¡¯ç¤ºï¼ˆrunSummaryCountUp æœƒ reset/éš±è—ï¼‰
  if(ovBreakdown) ovBreakdown.style.display = "block";

}

/* =========================
   Spawn / Drop
========================= */
function spawnBlock(){
  if(state!=="running") return;
  if(spawnQueued) return;
  if(inputLock) return;

  measureUiBottom();

  const nextLvl = level + 1;
  const { w, h } = sizeForLevel(nextLvl);

  const towerTopY = getTowerTopWorldY();

  const gapByLevel = CRANE.gapMax - Math.min(40, level * 1.2);
  const GAP_ABOVE_TOWER = Math.max(CRANE.gapMin, gapByLevel);

  let spawnY = towerTopY - GAP_ABOVE_TOWER;

  const safeTopWorldY = currentScrollY + (uiBottomPx + UI_SAFE.topPad);
  const needMinSpawnY = safeTopWorldY + UI_SAFE.craneMargin + (h/2) + (0.293 * craneRadius);

  if (spawnY < needMinSpawnY) {
    const desiredTopOnScreen = uiBottomPx + UI_SAFE.topPad + UI_SAFE.craneMargin;
    const camNeed = spawnY - desiredTopOnScreen;
    cameraTargetY = Math.min(cameraTargetY, Math.max(0, camNeed));
  }

  const MIN_CLEAR_FROM_GROUND = 200;
  spawnY = Math.min(spawnY, groundY - MIN_CLEAR_FROM_GROUND);

  const hue = (level * 28 + Math.random()*12) % 360;
  const baseColor = `hsl(${hue}, 72%, 62%)`;

  currentCraneBlock = Bodies.rectangle(viewW/2, spawnY, w, h, {
    isStatic:true,
    isSensor:true,
    restitution:MATERIAL.restitution,
    friction:MATERIAL.friction,
    frictionStatic:MATERIAL.frictionStatic,
    frictionAir:MATERIAL.frictionAir,
    density:MATERIAL.density,
    sleepThreshold: 60,
    render:{ visible:false }
  });

  currentCraneBlock.plugin = currentCraneBlock.plugin || {};
  currentCraneBlock.plugin.baseColor = baseColor;
  currentCraneBlock.plugin.drawH = h;

  cranePivotX = viewW/2;
  cranePivotY = spawnY - craneRadius;

  World.add(world,currentCraneBlock);
  cameraTargetY = Math.min(cameraTargetY, computeCameraTargetFromSafeTop());
}

function drop(){
  if(state!=="running") return;
  if(inputLock) return;
  if(!currentCraneBlock) return;
  if(fallingBlock || pendingCommit) return;

  inputLock = true;

  const b=currentCraneBlock;
  Body.setStatic(b,false);
  b.isSensor=false;

  b.isSleeping = false;
  b.sleepThreshold = 0;

  Body.setAngularVelocity(b,0);
  Body.setVelocity(b,{x:0,y:1.2});

  currentCraneBlock=null;
  fallingBlock=b;
}

/* =========================
   Landing pipeline
========================= */
function stabilizeOnLanding(body){
  const prevAir=body.frictionAir;
  body.frictionAir=LANDING_STABILIZE.frictionAirBoost;

  Body.setVelocity(body,{
    x: body.velocity.x * LANDING_STABILIZE.velXScale,
    y: body.velocity.y * LANDING_STABILIZE.velYScale
  });
  Body.setAngularVelocity(body, body.angularVelocity * LANDING_STABILIZE.angScale);

  setTimeout(()=>{ if(state==="running") body.frictionAir=prevAir; }, LANDING_STABILIZE.durationMs);
}

function beginPendingCommit(body, landedOn){
  // âœ… ç¬¬ä¸€å¡Šè½åœ°ï¼šç¢°æ’ç•¶ä¸‹å°±è§¸ç™¼ FXï¼ˆç«‹åˆ»ï¼‰
  const isFirstLanding = (level === 0);
  
  if(isFirstLanding && !didFirstLandFX){
    didFirstLandFX = true;
    reinforceBase(body);
    spawnParticles(body.position.x, body.position.y, 34);
    startShake(180, 7);
  } 

  const base = landedOn || (stackedBlocks.length>0 ? stackedBlocks[stackedBlocks.length-1] : ground);

  const diff = Math.abs(body.position.x - base.position.x);
  const w = (body.bounds.max.x - body.bounds.min.x);

  if(diff > w*0.85){ startGameOver("é€£çºŒCOMBOï¼Œåˆ†æ•¸æœƒæ›´é«˜ï¼"); return; }

  if(!isFirstLanding){
    const perfect = diff < w*0.05;
    if(perfect){
      const nextCombo = combo + 1;
      const text = (nextCombo >= 2) ? `${nextCombo} COMBO!` : "PERFECT!";
      addPopup("combo", text, body.position.x, body.position.y-56);
      spawnParticles(body.position.x, body.position.y, (nextCombo>=2) ? 30 : 22);
    }else{
      addPopup("nice","NICE", body.position.x, body.position.y-56);
      spawnParticles(body.position.x, body.position.y, 16);
    }
  }

  stabilizeOnLanding(body);

  pendingCommit = {
    body,
    base,
    startTs: engine.timing.timestamp,
    startX: body.position.x,
    startY: body.position.y,
    diff,
    w
  };

  fallingBlock = null;
}

function updatePendingCommit(nowTs){
  if(!pendingCommit || state!=="running") return;
  const b = pendingCommit.body;

  if (b.position.y > currentScrollY + viewH + FAIL.outOfViewPadding ||
      b.position.x < -FAIL.xPadding || b.position.x > viewW + FAIL.xPadding ||
      b.position.y > WORLD_HEIGHT + FAIL.outOfWorldPadding) {
    startGameOver("å»ºç¯‰æ‰è½ï¼");
    return;
  }

  const elapsed = nowTs - pendingCommit.startTs;
  const yDrop = b.position.y - pendingCommit.startY;
  const xDrift = Math.abs(b.position.x - pendingCommit.startX);
  const absAngle = Math.abs(b.angle);
  const absOmega = Math.abs(b.angularVelocity);
  const rf = relaxFactor();

  if (absAngle > STABILITY.maxAngleRad * rf) { startGameOver("æˆ¿å­å‚¾å€’äº†ï¼"); return; }
  if (yDrop    > STABILITY.maxYDrop    * rf) { startGameOver("æˆ¿å­å‚¾å€’äº†ï¼"); return; }
  if (xDrift   > STABILITY.maxXDrift   * rf) { startGameOver("æˆ¿å­å‚¾å€’äº†ï¼"); return; }

  if (elapsed >= STABILITY.windowMs) {
    if (absOmega > STABILITY.maxOmega * rf) { startGameOver("æˆ¿å­å‚¾å€’äº†ï¼"); return; }
    commitSuccess();
  }
}

  function commitSuccess(){
    if(!pendingCommit || state!=="running") return;

    const { body, diff, w, base } = pendingCommit;

    //ï¼ˆå¦‚æœä½ åŸæœ¬æœ‰ glue / constraint çš„æ®µè½ï¼Œæ”¾é€™è£¡ï¼‰
    if (base && base !== ground) {
      const glue = Constraint.create({
        bodyA: body,
        bodyB: base,
        pointA: { x: 0, y: 0 },
        pointB: { x: 0, y: 0 },
        stiffness: 0.18,
        damping: 0.12
      });
      World.add(world, glue);

      body.plugin = body.plugin || {};
      body.plugin.glue = glue;
    }

    const isFirstLanding = (level === 0);

    const segPrev = segmentIdForLevel(level);
    level++;
    const segNow = segmentIdForLevel(level);

    // âœ… å³æ™‚åŠ åˆ†ï¼ˆè£œå› v2.19ï¼‰
    if(!isFirstLanding){
      const perfect = diff < w*0.05;
      if(perfect){
        combo++;
        score += 10 + (combo * 25);
        totalPerfect++;
      }else{
        combo = 0;
        score += 10;
      }

      const nowGlow = engine.timing.timestamp;
      body.plugin = body.plugin || {};
      body.plugin.glowUntil = nowGlow + (perfect ? 520 : 320);
    }else{
      combo = 0;
    }

    // ç ´é—œåˆ¤å®š
    if(level >= MAX_LEVEL){
      stackedBlocks.push(body);
      pendingCommit = null;
      updateUI();
      endRound("ç ´é—œï¼", "win");
      return;
    }

      const now = engine.timing.timestamp;
      body.plugin = body.plugin || {};
      body.plugin.stableUntil = now + 420;

      stackedBlocks.push(body);

      if(segNow !== segPrev) sealOldSegment();

      timeLeft = roundTime;
      updateTimerUI();
      setBackgroundForLevelSmooth(level);
      updateUI();

      pendingCommit = null;

      inputLock = false;
      spawnQueued = true;
      setTimeout(()=>{
        spawnQueued = false;
        if(state==="running") spawnBlock();
      }, 140);
    }

/* =========================
   Collision rule
========================= */
Events.on(engine,'collisionStart',(event)=>{
  if(state!=="running") return;
  if(!fallingBlock || pendingCommit) return;

  for(const pair of event.pairs){
    const hitFalling = (pair.bodyA===fallingBlock || pair.bodyB===fallingBlock);
    if(!hitFalling) continue;

    const other = (pair.bodyA===fallingBlock) ? pair.bodyB : pair.bodyA;

    if(other === ground){
      if(level > 0){ startGameOver("é‚„æˆ‘é ­æœŸæ¬¾ï¼"); return; }
      beginPendingCommit(fallingBlock, ground);
      return;
    }
    beginPendingCommit(fallingBlock, other);
    return;
  }
});

/* =========================
   Collapse detector
========================= */
function updateCollapseDetector(dt){
  if(state!=="running") return;
  if(level < 2) { collapseBadMs = 0; return; }

  let bad = false;
  const now = engine.timing.timestamp;
  const active = getActiveBlocks();

  for(const b of active){
    const stableUntil = b.plugin?.stableUntil || 0;
    if(now < stableUntil) continue;

    if(b.position.x < -COLLAPSE.xPadding || b.position.x > viewW + COLLAPSE.xPadding){
      bad = true; break;
    }
    if(b.position.y > WORLD_HEIGHT + FAIL.outOfWorldPadding){
      bad = true; break;
    }
  }

  if(!bad){
    for(const bb of active){
      const stableUntil2 = bb.plugin?.stableUntil || 0;
      if(now < stableUntil2) continue;
      if(bb.plugin?.sealed) continue;

      const absAngle = Math.abs(bb.angle);
      const absOmega = Math.abs(bb.angularVelocity);
      const sp = Math.hypot(bb.velocity.x, bb.velocity.y);
      const rf = relaxFactor();

      if(absAngle > COLLAPSE.angleRad * rf || absOmega > COLLAPSE.omega * rf || sp > COLLAPSE.speed * rf){
        bad = true; break;
      }
    }
  }

  if(pendingCommit || fallingBlock){
    if(bad) collapseBadMs += dt*1000 * 0.55;
    else collapseBadMs = Math.max(0, collapseBadMs - dt*1000 * 0.7);
  } else {
    if(bad) collapseBadMs += dt*1000;
    else collapseBadMs = Math.max(0, collapseBadMs - dt*1000 * 0.9);
  }

  if(collapseBadMs >= COLLAPSE.holdMs) startGameOver("è“‹è¶Šé«˜ï¼Œåˆ†æ•¸è¶Šé«˜ï¼");
}

/* =========================
   å›åˆçµæŸ
========================= */
function endRound(reason, mode){
  if(state!=="running" && state!=="collapsing") return;

  endReason = reason;

  inputLock = true;

  const rScore = computeRoundScore();
  roundScores[roundIndex-1] = rScore;

  if(mode === "timeout"){
    state = "ended";
    showRoundSummaryUI({ mode, reason, roundScore: rScore });
    return;
  }
  if(mode === "win"){
    state = "ended";
    showRoundSummaryUI({ mode, reason, roundScore: rScore });
    return;
  }
  if(mode === "collapse"){
    state = "ended";
    showRoundSummaryUI({ mode, reason, roundScore: rScore });
    return;
  }
}

function showRoundSummaryUI({ mode, reason, roundScore }){
  const isLast = (roundIndex === ROUND_COUNT);

  if(!isLast){
    // âœ… Round1/2ï¼šã€ŒéŠæˆ²çµæŸã€æ”¹æˆã€Œä¸­å ´çµç®—ã€
    const titleText = "ä¸­å ´çµç®—";
    const subText = reason;

    showOverlaySummaryBase({
      titleText,
      subText,
      buttonText: "ä¸‹ä¸€å›åˆ",
      showLB: false,
      isLastRound: false
    });

    runSummaryCountUp({
      isLast: false,
      roundScore,
      totalScore: 0,
      showCumulativeAfterRound2: (roundIndex === 2)
    });

    return;
  }

  // Round3 ìœ ì§€ï¼šéŠæˆ²çµæŸ/æ­å–œç ´é—œç…§ä½ åŸæœ¬ï¼ˆé€™è£¡ä¿å®ˆä¿ç•™ï¼‰
  const total = (roundScores[0]||0) + (roundScores[1]||0) + (roundScores[2]||0);
  const titleText = (mode === "win") ? "æ­å–œç ´é—œ" : "éŠæˆ²çµæŸ";
  const subText = reason;

  showOverlaySummaryBase({
    titleText,
    subText,
    buttonText: "å†ç©ä¸€æ¬¡",
    showLB: true,
    isLastRound: true
  });

  tsEnd = Date.now();
  const arr = addToLB({ runId, playerId, total, tsEnd });
  renderLB(arr, runId);

  async function submitScoreToFirestore({ playerId, total, tsEnd, runId }){
  const db = window.__db;
  const auth = window.__auth;
  if(!db || !auth?.currentUser) return;

  await addDoc(collection(db, "leaderboard"), {
    playerId,
    total,
    tsEnd,
    runId,
    uid: auth.currentUser.uid,
    createdAt: serverTimestamp()
  });
}

  runSummaryCountUp({
    isLast: true,
    roundScore: 0,
    totalScore: total,
    showCumulativeAfterRound2: false
  });

  submitScoreToFirestore({ playerId, total, tsEnd, runId }).catch(()=>{});
}

function startGameOver(reason){
  if(state!=="running") return;
  endRound(reason, "collapse");
}

/* =========================
   Update loop
========================= */
Events.on(engine,'beforeUpdate',()=>{
  const ts=engine.timing.timestamp;
  if(lastTimestamp==null) lastTimestamp=ts;
  const dt=(ts-lastTimestamp)/1000;
  lastTimestamp=ts;

  if(shakeMs > 0){
  shakeMs -= dt * 1000;
  if(shakeMs <= 0){
    shakeMs = 0;
    shakeAmp = 0;
  }else{
    // ç·šæ€§æˆ–æŒ‡æ•¸è¡°æ¸›éƒ½å¯ä»¥ï¼Œé€™è£¡ç”¨ç·šæ€§è¡°æ¸›
    const k = shakeMs / 180; // 180ms æ˜¯é è¨­å€¼
    shakeAmp = Math.max(0.5, shakeAmp * (0.85 + 0.15*k));
  }
}

  updateCamera();
  updateVfx(dt);

  if(state!=="running") return;

  dampSealedBlocks();

  if(currentCraneBlock){
    const SPD_MIN = 0.028;
    const SPD_MAX = 0.062;
    const SPD_LVL_END = 61;

    const t = clamp01(level / SPD_LVL_END);
    const te = t * t * (3 - 2 * t);
    const speed = lerp(SPD_MIN, SPD_MAX, te);

    swingTime += speed;

    const AMP_MAX = Math.PI / 4;
    const AMP_MIN = Math.PI / 6;
    const AMP_LVL_END = 35;

    const ta = clamp01(level / AMP_LVL_END);
    const tae = ta * ta * (3 - 2 * ta);
    const amp = lerp(AMP_MAX, AMP_MIN, tae);

    const angle = Math.sin(swingTime) * amp;

    const nextX=cranePivotX+Math.sin(angle)*craneRadius;
    const nextY=cranePivotY+Math.cos(angle)*craneRadius;

    Body.setPosition(currentCraneBlock,{x:nextX,y:nextY});
    Body.setAngle(currentCraneBlock,-angle);
    Body.setVelocity(currentCraneBlock,{x:0,y:0});
    Body.setAngularVelocity(currentCraneBlock,0);
  }

  if(level>0){
    timeLeft-=dt;
    updateTimerUI();
    if(timeLeft<=0){
      endRound("æ™‚é–“è€—ç›¡ï¼", "timeout");
      return;
    }
  }

  if(fallingBlock){
    const b=fallingBlock;
    if(b.position.y>currentScrollY+viewH+FAIL.outOfViewPadding){ startGameOver("å»ºç¯‰æ‰è½ï¼"); return; }
    if(b.position.x<-FAIL.xPadding || b.position.x>viewW+FAIL.xPadding){ startGameOver("å»ºç¯‰æ‰è½ï¼"); return; }
    if(b.position.y>WORLD_HEIGHT+FAIL.outOfWorldPadding){ startGameOver("å»ºç¯‰æ‰è½ï¼"); return; }
  }

  updatePendingCommit(ts);
  updateCollapseDetector(dt);
});

function updateVfx(dt){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.life-=dt;
    if(p.life<=0){particles.splice(i,1);continue;}
    p.vy+=8*dt;
    p.x+=p.vx; p.y+=p.vy;
    p.vx*=0.98; p.vy*=0.98;
  }
  for(let i=popups.length-1;i>=0;i--){
    const m=popups[i];
    m.age+=dt; m.life-=dt;
    if(m.life<=0){popups.splice(i,1);continue;}
    m.y+=(m.rise*dt);
  }
}

/* =========================
   Drawing helpersï¼ˆä¿ç•™ä½ åŸæœ¬ï¼‰
========================= */
function drawRoundedQuad(ctx, pts, r){
  const n = pts.length;
  const clampR = (pPrev, p, pNext, rr)=>{
    const d1 = Math.hypot(p.x - pPrev.x, p.y - pPrev.y);
    const d2 = Math.hypot(pNext.x - p.x, pNext.y - p.y);
    return Math.min(rr, d1*0.35, d2*0.35);
  };
  ctx.beginPath();
  for(let i=0;i<n;i++){
    const pPrev = pts[(i-1+n)%n];
    const p = pts[i];
    const pNext = pts[(i+1)%n];
    const rr = clampR(pPrev,p,pNext,r);

    const v1x = pPrev.x - p.x, v1y = pPrev.y - p.y;
    const v2x = pNext.x - p.x, v2y = pNext.y - p.y;

    const len1 = Math.hypot(v1x,v1y) || 1;
    const len2 = Math.hypot(v2x,v2y) || 1;

    const p1 = { x: p.x + (v1x/len1)*rr, y: p.y + (v1y/len1)*rr };
    const p2 = { x: p.x + (v2x/len2)*rr, y: p.y + (v2y/len2)*rr };

    if(i===0) ctx.moveTo(p1.x,p1.y);
    else ctx.lineTo(p1.x,p1.y);

    ctx.quadraticCurveTo(p.x,p.y,p2.x,p2.y);
  }
  ctx.closePath();
  ctx.fill();
}
function hslToRgb(h, s, l){
  h/=360; s/=100; l/=100;
  const hue2rgb=(p,q,t)=>{
    if(t<0) t+=1;
    if(t>1) t-=1;
    if(t<1/6) return p+(q-p)*6*t;
    if(t<1/2) return q;
    if(t<2/3) return p+(q-p)*(2/3-t)*6;
    return p;
  };
  let r,g,b;
  if(s===0){ r=g=b=l; }
  else{
    const q = l < 0.5 ? l*(1+s) : l + s - l*s;
    const p = 2*l - q;
    r = hue2rgb(p,q,h + 1/3);
    g = hue2rgb(p,q,h);
    b = hue2rgb(p,q,h - 1/3);
  }
  return { r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255) };
}
function parseHsl(str){
  const m = /hsl\(([\d.]+),\s*([\d.]+)%?,\s*([\d.]+)%?\)/i.exec(str||"");
  if(!m) return {h:200,s:70,l:60};
  return {h:parseFloat(m[1]), s:parseFloat(m[2]), l:parseFloat(m[3])};
}
function rgbStr({r,g,b}, a=1){ return `rgba(${r},${g},${b},${a})`; }
function shadeHsl(hsl, dl){
  const {h,s,l}=parseHsl(hsl);
  const nl = Math.max(5, Math.min(95, l + dl));
  const rgb = hslToRgb(h,s,nl);
  return rgbStr(rgb, 1);
}

/* =========================
   Sky decorï¼ˆä¿ç•™ä½ åŸæœ¬ï¼‰
========================= */
function seededRand(seed){
  let x = Math.sin(seed) * 10000;
  return x - Math.floor(x);
}
function drawCloud(ctx, x, y, s, a){
  ctx.save();
  ctx.globalAlpha = a;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.beginPath();
  ctx.arc(x, y, 18*s, 0, Math.PI*2);
  ctx.arc(x+20*s, y-10*s, 22*s, 0, Math.PI*2);
  ctx.arc(x+45*s, y, 18*s, 0, Math.PI*2);
  ctx.arc(x+25*s, y+12*s, 22*s, 0, Math.PI*2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}
function drawSun(ctx, x, y, r){
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,230,120,1)";
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.18;
  ctx.beginPath(); ctx.arc(x,y,r*2.4,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawMoon(ctx, x, y, r){
  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "rgba(230,235,255,1)";
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation = "destination-out";
  ctx.beginPath(); ctx.arc(x+r*0.42,y-r*0.12,r*0.95,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}
function drawStar(ctx, x, y, r, a){
  ctx.save();
  ctx.globalAlpha = a;
  ctx.fillStyle = "rgba(255,255,255,1)";
  ctx.beginPath();
  ctx.moveTo(x, y-r);
  ctx.lineTo(x+r*0.55, y+r*0.2);
  ctx.lineTo(x-r*0.55, y+r*0.2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}
function drawPlanet(ctx, x, y, r){
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(160,210,255,1)";
  ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "rgba(255,255,255,1)";
  ctx.lineWidth = 6;
  ctx.beginPath();
  ctx.ellipse(x, y+2, r*1.4, r*0.55, -0.35, 0, Math.PI*2);
  ctx.stroke();
  ctx.restore();
}
function drawSkyDecor(ctx){
  const cam = skyScrollY;
  const par1 = cam * 0.25;
  const par2 = cam * 0.12;

  // âœ… ä¾å›åˆä¸»é¡Œè¦†è“‹ï¼ˆRound2/3ï¼‰
  let hasCloud = level < 15;
  let hasSun = level < 10;
  let hasMoon = (level >= 10 && level < 20);
  let hasStars = level >= 15;
  let hasPlanet = level >= 22;

  if(bgTheme === "dusk"){
    hasCloud = true;
    hasSun = true;     // é»ƒæ˜å¯ä»¥ç•«ã€Œä½ä¸€é»çš„å¤ªé™½ã€
    hasMoon = false;
    hasStars = false;  // ä¹Ÿå¯ä»¥æ”¹ true + å°‘é‡æ˜Ÿæ˜Ÿï¼Œçœ‹ä½ é¢¨æ ¼
    hasPlanet = false;
  }else if(bgTheme === "night"){
    hasCloud = false;  // å¤œæ™šé€šå¸¸é›²å°‘ï¼ˆæˆ–ä½ æƒ³ç•™ä¹Ÿè¡Œï¼‰
    hasSun = false;
    hasMoon = true;
    hasStars = true;
    hasPlanet = true;  // è¡Œæ˜Ÿ/å…‰æšˆæ›´æœ‰æ„Ÿ
  }

  // â†“â†“â†“ ä¸‹é¢åŸæœ¬çš„ç¹ªè£½ç¨‹å¼ç¢¼ç…§èˆŠï¼Œåªæ˜¯ç”¨ä¸Šé¢çš„ hasCloud/hasSun... ä¾†æ±ºå®š
  if(hasCloud){
    const n = 5;
    for(let i=0;i<n;i++){
      const seed = 1000 + i*77;
      const rx = seededRand(seed) * viewW;
      const ry = 80 + seededRand(seed+9) * 180;
      const s = 0.7 + seededRand(seed+3)*0.9;
      const y = ry + (par2 % 240) * 0.25;
      drawCloud(ctx, rx, y, s, 0.55);
    }
  }

  // âœ… é»ƒæ˜å¤ªé™½ä½ç½®å¯ä»¥å£“ä½ä¸€é»
  if(hasSun){
    const y = (bgTheme === "dusk") ? (viewH*0.28 + (par2 % 200)*0.12) : (110 + (par2 % 200)*0.12);
    drawSun(ctx, viewW*0.78, y, 34);
  }
  if(hasMoon){
    drawMoon(ctx, viewW*0.80, 120 + (par2 % 260)*0.10, 28);
  }

  if(hasStars){
    const starCount = (bgTheme === "night") ? 46 : 24; // å¤œæ™šæ˜Ÿæ˜Ÿæ›´å¤š
    for(let i=0;i<starCount;i++){
      const seed = 5000 + i*31;
      const x = seededRand(seed) * viewW;
      const baseY = 40 + seededRand(seed+5) * 280;
      const y = baseY + (par1 % 360) * 0.08;
      const r = 3 + seededRand(seed+8)*3.5;
      const a = 0.25 + seededRand(seed+11)*0.55;
      drawStar(ctx, x, y, r, a);
    }
  }

  if(hasPlanet){
    drawPlanet(ctx, viewW*0.18, 140 + (par1 % 220)*0.10, 34);
  }
}

/* =========================
   Renderï¼ˆä¿ç•™ä½ åŸæœ¬ + æ•´æ®µç…§èˆŠï¼‰
========================= */
Events.on(render,'afterRender',()=>{
  const ctx = render.context;
  const now = engine.timing.timestamp;

  const camY = render.bounds.min.y;

  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  drawSkyDecor(ctx);
  ctx.restore();

  const toScreenY = (y)=> y - camY;

  if(ground){
    const gy = toScreenY(groundY - groundH/2);
    ctx.save();
    ctx.fillStyle = "rgba(44,62,80,1)";
    ctx.fillRect(0, gy, viewW, groundH);
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0, gy, viewW, 10);
    ctx.restore();
  }

  const list = [];
  list.push(...stackedBlocks);
  if(currentCraneBlock) list.push(currentCraneBlock);
  if(fallingBlock) list.push(fallingBlock);
  if(pendingCommit?.body) list.push(pendingCommit.body);

  for(const b of list){
    const w = (b.bounds.max.x - b.bounds.min.x);
    const h = (b.plugin && b.plugin.drawH) ? b.plugin.drawH : (b.bounds.max.y - b.bounds.min.y);

    const baseColor = b.plugin?.baseColor || "hsl(200,70%,60%)";
    const front = shadeHsl(baseColor, 0);
    const top = shadeHsl(baseColor, +14);
    const side = shadeHsl(baseColor, -14);

    const dx = Math.max(3, 9 * (h/BASE_H));
    const dy = -Math.max(2, 7 * (h/BASE_H));
    const r  = Math.max(2, 7 * (h/BASE_H));

    ctx.save();
    ctx.translate(b.position.x, toScreenY(b.position.y));
    ctx.rotate(b.angle);

    const glowUntil=b.plugin?.glowUntil || 0;
    if(now<glowUntil){
      ctx.shadowBlur=18;
      ctx.shadowColor="rgba(255,209,102,0.75)";
    }else{
      ctx.shadowBlur=0;
    }

    ctx.fillStyle = top;
    drawRoundedQuad(ctx, [
      {x:-w/2,      y:-h/2},
      {x:-w/2+dx,   y:-h/2+dy},
      {x: w/2+dx,   y:-h/2+dy},
      {x: w/2,      y:-h/2}
    ], r);

    ctx.fillStyle = side;
    drawRoundedQuad(ctx, [
      {x: w/2,      y:-h/2},
      {x: w/2+dx,   y:-h/2+dy},
      {x: w/2+dx,   y: h/2+dy},
      {x: w/2,      y: h/2}
    ], r);

    ctx.fillStyle = front;
    ctx.beginPath();
    if(typeof ctx.roundRect==="function") ctx.roundRect(-w/2, -h/2, w, h, Math.max(3, 10*(h/BASE_H)));
    else ctx.rect(-w/2, -h/2, w, h);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.moveTo(-w*0.22, -h/2);
    ctx.lineTo(0, -h*0.92);
    ctx.lineTo(w*0.22, -h/2);
    ctx.closePath();
    ctx.fill();

    const win = "rgba(255,255,255,0.28)";
    const winHi = "rgba(255,255,255,0.16)";
    const rows = [-h*0.15, h*0.18];
    const ww = Math.max(3, 10*(h/BASE_H));
    const wh = Math.max(4, 12*(h/BASE_H));
    for(const rowY of rows){
      for(let i=-1;i<=1;i++){
        const wx = i*(w/4) - ww*0.5;
        const wy = rowY - wh*0.6;
        ctx.fillStyle = win;
        ctx.fillRect(wx, wy, ww, wh);
        ctx.fillStyle = winHi;
        ctx.fillRect(wx+ww*0.16, wy+wh*0.14, ww*0.68, wh*0.26);
      }
    }

    ctx.restore();
  }

  ctx.save();
  ctx.globalCompositeOperation="lighter";
  for(const p of particles){
    const alpha=Math.max(0,Math.min(1,p.life/0.85));
    ctx.globalAlpha=alpha;
    ctx.beginPath();
    ctx.arc(p.x, toScreenY(p.y), 2.0, 0, Math.PI*2);
    ctx.fillStyle="rgba(255, 209, 102, 1)";
    ctx.fill();
  }
  ctx.restore();
  ctx.globalAlpha=1;
  ctx.globalCompositeOperation="source-over";

  ctx.save();
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  for(const m of popups){
    const t01=clamp01(m.age/0.75);
    const s=popupScale(t01);
    const a=popupAlpha(t01);
    const isComboKind=(m.kind==="combo"||m.kind==="perfect");
    const color=isComboKind?"rgba(255,209,102,1)":"rgba(255,255,255,1)";
    const baseSize=isComboKind?30:20;
    const size=Math.round(baseSize*s);

    ctx.globalAlpha=a;
    ctx.font=`900 ${size}px Segoe UI`;
    ctx.shadowBlur=isComboKind?16:10;
    ctx.shadowColor=isComboKind?"rgba(255,209,102,0.65)":"rgba(255,255,255,0.45)";
    ctx.fillStyle=color;
    ctx.fillText(m.text, m.x, toScreenY(m.y));
  }
  ctx.restore();
  ctx.globalAlpha=1;
});

/* =========================
   Leaderboard (local) - ä¸‰å›åˆç¸½åˆ†
========================= */
const LB_KEY = "star_builder_lb_v2_run_total";
const LB_MAX = 50;

function loadLB(){
  try{
    const raw = localStorage.getItem(LB_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  }catch(e){ return []; }
}
function saveLB(arr){
  try{ localStorage.setItem(LB_KEY, JSON.stringify(arr.slice(0, LB_MAX))); }
  catch(e){}
}
function sortLB(arr){
  arr.sort((a,b)=>{
    if((b.total||0) !== (a.total||0)) return (b.total||0) - (a.total||0);
    return (a.tsEnd||0) - (b.tsEnd||0);
  });
  return arr;
}

playerId = playerId || "-";

function addToLB(entry){
  const arr = loadLB();
  arr.push(entry);
  sortLB(arr);
  saveLB(arr);
  return arr;
}
function renderLB(arr, highlightRunId){
  const wrap = document.getElementById('lb-wrap');
  const list = document.getElementById('lb-list');
  if(!wrap || !list) return;

  wrap.style.display = "block";
  list.innerHTML = "";

  const top = arr.slice(0, 30);
  top.forEach((it, idx)=>{
    const row = document.createElement('div');
    row.className = "lb-row" + (it.runId === highlightRunId ? " lb-me" : "");
    const pid = (it.playerId != null && it.playerId !== "") ? it.playerId : "-";
    row.innerHTML = `<div>${idx+1}</div><div>${pid}</div><div>${it.total||0}</div>`;
    list.appendChild(row);
  });

  const myIndex = arr.findIndex(x=>x.runId===highlightRunId);
  if(myIndex >= 30){
    const sep = document.createElement('div');
    sep.className = "lb-row";
    sep.innerHTML = `<div>â€¦</div><div>â€¦</div><div>â€¦</div>`;
    list.appendChild(sep);

    const it = arr[myIndex];
    const row = document.createElement('div');
    row.className = "lb-row lb-me";
    const pid = (it.playerId != null && it.playerId !== "") ? it.playerId : "-";
    row.innerHTML = `<div>${myIndex+1}</div><div>${pid}</div><div>${it.total||0}</div>`;
    list.appendChild(row);
  }
}

/* =========================
   Retry / Input / Resize
========================= */

/* =========================
   Login System
========================= */
function showLogin(){
  login.classList.add('show');
  login.removeAttribute('inert');
  login.setAttribute('aria-hidden','false');
  idInput?.focus();
}

function hideLogin(){
  document.activeElement?.blur();
  login.classList.remove('show');
  login.setAttribute('aria-hidden','true');
  login.setAttribute('inert','');
}

function hideOverlay(){
  document.activeElement?.blur();
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden','true');
  overlay.setAttribute('inert','');
}

function onLogin(){
  console.log("onLogin fired");
  const v = validatePlayerId(idInput?.value);
  if(!v.ok){
    if(loginErr) loginErr.textContent = v.msg;
    return;
  }

  if(loginErr) loginErr.textContent = ""; // âœ… æ¸…æ‰éŒ¯èª¤è¨Šæ¯

  playerId = v.id;
  localStorage.setItem("player_id", playerId);

  hideLogin();

  runId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
  tsStart = Date.now();

  startRound(1);
  spawnBlock();
}

btnLogin?.addEventListener('click', onLogin);
idInput?.addEventListener('keydown', (e)=>{
  if(e.key === "Enter") onLogin();
});

function onPrimaryButton(e){
  e.preventDefault();
  e.stopPropagation();

  if(state !== "ended") return;
  if(btnRetry.disabled) return;

  if(roundIndex < ROUND_COUNT){
    const next = roundIndex + 1;
    resetWorldForNewRound();  // âœ… æ¸…å¡”ã€æ¸…æ‰èˆŠçš„ç‰©ç†ç‰©ä»¶ã€é‡å»ºåœ°æ¿ã€é‡è¨­ç›¸æ©Ÿç­‰
    startRound(next);         // âœ… é‡è¨­ score/level/combo/timeLeft + é—œé–‰ overlay
    spawnBlock();             // âœ… ç”Ÿæˆä¸‹ä¸€å›åˆçš„ç¬¬ä¸€å¡Šï¼ˆä¸ç„¶ä½ æœƒå¡ä½ï¼‰
  }else{
    location.reload();
  }
}

btnRetry.addEventListener('click', onPrimaryButton);
btnRetry.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPrimaryButton(e); }, { passive:false });

function shouldIgnoreGlobalInput(e){
  // ç™»å…¥/çµç®— overlay é–‹è‘—ï¼Œå°±ä¸è¦æŠŠè§¸æ§ç•¶æˆ drop
  if(login?.classList.contains('show')) return true;
  if(overlay?.classList.contains('show')) return true;

  // å¦å¤–ä¿éšªï¼šé»åˆ°æŒ‰éˆ•/è¼¸å…¥æ¡†ä¹Ÿä¸è¦æ””
  const t = e?.target;
  if(t && (t.closest?.('button') || t.closest?.('input') || t.closest?.('#login') || t.closest?.('#overlay'))) return true;

  return false;
}

window.addEventListener('mousedown', (e)=>{
  if(shouldIgnoreGlobalInput(e)) return;
  drop();
});

window.addEventListener('touchstart', (e)=>{
  if(shouldIgnoreGlobalInput(e)) return;
  e.preventDefault(); // åªåœ¨éŠæˆ²å€æ‰ preventDefault
  drop();
}, { passive:false });

function rebuildGround(){
  if(ground) World.remove(world, ground);
  groundY = WORLD_HEIGHT - 60;
  ground = Bodies.rectangle(viewW/2, groundY, viewW, groundH, {
    isStatic: true,
    restitution: 0.0,
    friction: 1.0,
    frictionStatic: 1.0,
    render: { visible:false }
  });
  World.add(world, ground);
}

function resizeRender(){
  viewW = window.innerWidth;
  viewH = window.innerHeight;
  WORLD_HEIGHT = viewH * 60;

  // âœ… æ­£ç¢ºæ”¹å°ºå¯¸æ–¹å¼ï¼ˆ0.19.0 å¯ç”¨ï¼‰
  render.canvas.width  = viewW * (window.devicePixelRatio || 1);
  render.canvas.height = viewH * (window.devicePixelRatio || 1);
  render.canvas.style.width  = viewW + "px";
  render.canvas.style.height = viewH + "px";

  render.options.width = viewW;
  render.options.height = viewH;

  // pixel ratio
  Render.setPixelRatio(render, window.devicePixelRatio || 1);

  rebuildGround();
  measureUiBottom();

  const t = computeCameraTargetFromSafeTop();
  cameraTargetY = Math.min(cameraTargetY, t);
  currentScrollY = Math.min(currentScrollY, cameraTargetY);
  applyCamera();

  if(overlay.classList.contains('show')) resizeFxCanvas();
}

window.addEventListener('resize', resizeRender);

/* =========================
   Round åˆ‡æ›ï¼šæ¸…å¡”é‡ç©
========================= */
function removeBodySafe(b){
  if(!b) return;
  try{ World.remove(world, b); }catch(e){}
}
function resetWorldForNewRound(){
  if(currentCraneBlock){ removeBodySafe(currentCraneBlock); currentCraneBlock=null; }
  if(fallingBlock){ removeBodySafe(fallingBlock); fallingBlock=null; }
  if(pendingCommit?.body){ removeBodySafe(pendingCommit.body); }
  pendingCommit = null;

  while(stackedBlocks.length){
    const b = stackedBlocks.pop();
    if(b?.plugin?.glue) removeBodySafe(b.plugin.glue);
    removeBodySafe(b);
  }

  particles.length = 0;
  popups.length = 0;

  if(ground){ removeBodySafe(ground); ground=null; }
  rebuildGround();

  initCamera();
  setBackgroundForLevelSmooth(0);

  lastTimestamp = null;
  collapseBadMs = 0;
  swingTime = 0;
}

function startRound(idx){
  roundIndex = idx;
  roundTime = getRoundTime(roundIndex);

  state = "running";
  inputLock = false;
  spawnQueued = false;
  score = 0;
  level = 0;
  combo = 0;
  totalPerfect = 0;
  timeLeft = roundTime;

  setRoundHUD();
  updateTimerUI();
  updateUI();

  hideOverlay();
  didFirstLandFX = false;

  // âœ… å¥—ç”¨å›åˆèƒŒæ™¯ï¼ˆRound2 duskã€Round3 nightï¼‰
  applyRoundBackground();
}

function reinforceBase(body){
  body.friction = Math.max(body.friction || 0, BASE_ANCHOR.friction);
  body.frictionStatic = Math.max(body.frictionStatic || 0, BASE_ANCHOR.frictionStatic);
  body.frictionAir = Math.max(body.frictionAir || 0, BASE_ANCHOR.frictionAir);

  // ç«‹åˆ»æŠ‘åˆ¶ã€Œåº•åº§è¢«æ’å¾Œçš„æ»‘å‹•/æ—‹è½‰ã€ç´¯ç©
  Body.setVelocity(body, { x: body.velocity.x * BASE_ANCHOR.velXDamp, y: body.velocity.y });
  Body.setAngularVelocity(body, body.angularVelocity * BASE_ANCHOR.angDamp);
}

/* =========================
   VFX helpersï¼ˆéŠæˆ²å…§ï¼‰
========================= */
function spawnParticles(x,y,count=18){
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2;
    const sp=1.8+Math.random()*3.6;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp-1.6,life:0.5+Math.random()*0.35});
  }
}
function addPopup(kind,text,x,y){
  popups.push({kind,text,x,y,age:0,life:0.75,rise:-22});
}
function easeOutCubic(t){return 1-Math.pow(1-t,3);}
function popupScale(t01){
  if(t01<0.22){const u=t01/0.22;return 0.8+easeOutCubic(u)*0.7;}
  if(t01<0.42){const u=(t01-0.22)/0.20;return 1.5-easeOutCubic(u)*0.5;}
  return 1.0;
}
function popupAlpha(t01){
  if(t01<0.55) return 1;
  const u=(t01-0.55)/0.45;
  return 1-easeOutCubic(clamp01(u));
}

/* =========================
   Boot
========================= */
Render.run(render);
Runner.run(Runner.create(), engine);

runId = `${Date.now()}_${Math.random().toString(16).slice(2)}`;
tsStart = Date.now();

measureUiBottom();
setBackgroundForLevelSmooth(0);
initCamera(); // ç›¸æ©Ÿå¯ä»¥å…ˆ init

// âœ… é¡¯ç¤ºç™»å…¥ï¼ˆå¯å¸¶å…¥ä¸Šæ¬¡IDï¼‰
try{
  const saved = localStorage.getItem("player_id");
  if(saved && idInput) idInput.value = saved;
}catch(e){}
showLogin();

</script>
</body>
</html>
